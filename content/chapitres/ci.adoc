
[{invert}]
= Intégration Continue (CI)

[quote, Martin Fowler]
____
Continuous Integration doesn’t get rid of bugs, but it does make them
dramatically easier to find and remove.
____

== Pourquoi la CI ?

*But :* Détecter les fautes au plus tôt pour en limiter le coût

image::big-bugs.jpg[caption="Big Bugs",width=800]

[.small]
Source : http://cartoontester.blogspot.be/2010/01/big-bugs.html

== Qu'est ce que l'Intégration Continue ?

**Objectif :** que l'intégration de code soit un _non-évenement_

* Construire et intégrer le code *en continu*
* Le code est intégré *souvent* (au moins quotidiennement)
* Chaque intégration est validée par une exécution *automatisée*

== Et concrètement ?

image::fail-fast-continuous-integration.png[height=250]

* Un•e dévelopeu•se•r ajoute du code/branche/PR :
une requête HTTP est envoyée au système de "CI"
* Le système de CI compile et teste le code
* On ferme la boucle : Le résultat est renvoyé au dévelopeu•se•r•s

== Anatomie du déclenchement d'un job CI

image:ghci.svg[with="800"]

== Quelques moteurs de CI connus

* A héberger soit-même : https://www.jenkins.io/[Jenkins], https://about.gitlab.com/[GitLab], https://www.drone.io/[Drone CI], https://ovh.github.io/cds/[CDS]...
* Hébergés en ligne : https://travis-ci.org/[Travis CI], https://semaphoreci.com/[Semaphore CI], https://circleci.com/[Circle CI], https://codefresh.io/[Codefresh], https://docs.github.com/en/free-pro-team@latest/actions/quickstart[GitHub Actions]

== GitHub Actions

GitHub Actions est un moteur de CI/CD intégré à GitHub

* ✅ : Très facile à mettre en place, gratuit et intégré complètement
* ❌ : Utilisable uniquement avec GitHub, et DANS la plateforme GitHub

== Concepts de GitHub Actions

image::gh-actions-concepts.svg[width=800]

== Concepts de GitHub Actions - Step

Une *Step* (étape) est une tâche individuelle à faire effectuer par le CI :

* Par défaut c'est une commande à exécuter - mot clef `run`
* Ou une "action" (quel est le nom du produit déjà ?) - mot clef `uses`
** Réutilisables et https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/finding-and-customizing-actions[partageables]

== Concepts de GitHub Actions - Job

Un *Job* est un groupe logique de tâches :

* Enchaînement _séquentiel_ de tâches
* Regroupement logique : "qui a un sens" (exemple : )

== Concepts de GitHub Actions - Runner

Un *Runner* est un serveur distant sur lequel s'exécute un job.

* Mot clef `runs-on` dans la définition d'un job
* Défaut : machine virtuelle Ubuntu dans le cloud utilisé par GitHub
* https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners[D'autres types sont disponibles]
(macOS, Windows, etc.)
* Possibilité de fournir https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners[son propre serveur]

== Concepts de GitHub Actions - Workflow

Un *Workflow* est une procédure automatisée composée de plusieurs jobs,
décrite par un fichier YAML.

* On parle de "Workflow/Pipeline as Code"
* Chemin : `.github/workflows/<nom du workflow>.yml`
* On peut avoir _plusieurs_ fichiers donc _plusieurs_ workflows

== Concepts de GitHub Actions - Évènement

Un *évènement* du projet GitHub (push, merge, nouvelle issue, etc. ) déclenche l'exécution du workflow

* Plein de type d'évènements : push, issue, alarme régulière, favori, fork, etc.
* Le workflow est exécuté pour un commit donné (Rappel : "Workflow as Code")

== Concepts de GitHub Actions : Exemple

.Workflow File :
[source,yaml]
----
include::../code-samples/gh-actions/npm-example.yml[]
----

== Concepts de GitHub Actions - Récapépète

image::gh-actions-concepts.svg[width=800]

== Essayons GitHub Actions

* *But* : nous allons créer notre premier workflow dans GitHub Actions

* N'hésitez pas à utiliser la documentation de GitHub Actions:
** https://docs.github.com/en/free-pro-team@latest/actions[Accueil]
** https://docs.github.com/en/free-pro-team@latest/actions/quickstart[Quickstart]
** https://docs.github.com/en/free-pro-team@latest/actions/reference[Référence]

* Retournez dans le dépôt créé précédemment dans votre environnement gitpod

== Exemple simple avec GitHub Actions

* Créez le fichier `.github/workflows/bonjour.yml` avec le contenu suivant :

[source,yaml]
----
include::../code-samples/gh-actions/say-hello-full.yml[tags="common,simple-hello"]
----

* Revenez sur la page GitHub de votre projet et naviguez dans l'onglet "Actions" :
** Voyez-vous un workflow ? Et un Job ? Et le message affiché par la commande `echo` ?

== Exemple simple avec GitHub Actions : Récapépète

image::gh-actions-simple-example.svg[width=800]

== Exemple GitHub Actions : Checkout

* Supposons que l'on souhaite utiliser le code du dépôt...
** Essayez: modifiez le fichier `bonjour.yml` pour afficher le contenu de `README.md` :
+
[source,yaml]
----
include::../code-samples/gh-actions/say-hello-full.yml[tags="common,show-readme"]
----

* Est-ce que l'étape `cat README.md` se passe bien ? (SPOILER: non ❌ )

== Exercice GitHub Actions : Checkout

* *But* : On souhaite récupérer ("checkout") le code du dépôt dans le job

* C'est à vous d'essayer de _réparer_ le job :
** L'étape `cat README.md` doit être conservée et doit fonctionner
** Utilisez l'action "checkout" (https://github.com/marketplace/actions/checkout[Documentation]) du marketplace GitHub Action
** Vous pouvez vous inspirer du https://docs.github.com/en/free-pro-team@latest/actions/quickstart[Quickstart] de GitHub Actions

== Solution GitHub Actions : Checkout

[source,yaml]
----
include::../code-samples/gh-actions/say-hello-full.yml[tags="common,checkout,show-readme"]
----

== Exemple : Environnement d'exécution

* Notre pipeline de build dit que "la vache" doit afficher le contenu du fichier `README.md`
** WAT (Non, nous ne sommes pas fous) ?

[%steps]
* Essayez la commande `cat README.md | cowsay` dans GitPod
** Essayez de mettre à jour le workflow pour faire la même chose dans GitHub Actions
** SPOILER: ❌ (la commande `cowsay` n'est pas disponible dans le runner GitHub Actions)

== Exercice : Environnement d'exécution

* *But* : On souhaite utiliser une commande spécifique durant notre job

* Deux types de solutions existent, chacune avec ses inconvénients :
** Installer les outils manquants en préambule de chaque job (❌ lent ✅ facile )
** Utiliser Docker pour fabriquer une action GitHub (❌ complexe ✅ portable)

* C'est à vous :
** Cherchez comment installer `cowman` dans Ubuntu 18.04
** Appliquer cette solution dans votre job afin de le "réparer" et de voir la vache dans GitHub Actions.

== Solution : Environnement d'exécution

[source,yaml]
----
include::../code-samples/gh-actions/say-hello-full.yml[tags="common,checkout,cowsay"]
----
