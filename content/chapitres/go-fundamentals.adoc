= Ecrire du code!

== Hello golang!

== Golang, kesako? (1/2)

- Langage typé statiquement
- Génère un binaire executable
- Syntaxe proche du C.
- Langage facilitement les traitements concurents et le réseau.

== Golang, kesako? (2/2)

- Langage crée en 2009 en interne chez Google
- 1.0 livrée en Mars 2012
- Maintenant au coeur de nombreux projets (Docker, Kubernetes, Prometheus, CockroachDB...)
- Version actuelle 1.17.x

== Pourquoi un autre langage pour ce cours?

- Simple dans son design (mais pas simpliste!)
- Volontairement explicite
- Librairie standard extrêmement fournie
- Outillage pour le CI/CD très complet

== Démarer son environement gitpod

TODO BACKPORT

== Un premier programme écrit en go

Copiez le code donné dans un fichier `main.go`

```golang
package main

import "fmt"

func main() {
    fmt.Println("Hello ENSG!")
}
```

== Compiler et executer un programme (1/2)

```bash
# -o nom du fichier de sortie du compilateur.
go build -o main ./main.go

# Inspectez le fichier généré par le compilateur
file main

# C'est un executable, executons le!
./main
```

== Compiler et executer un programme 2/2

```bash
# Compile et execute votre programe, en une seule commande;
go run ./main.go
```

== Anatomie d'un fichier .go

```golang
// Donne le package dans lequel le fichier est défini.
package main

// Importe le package `fmt` de la librairie standard dans le fichier pour utiliser les symboles exposés par ce dernier.
import "fmt"

// Declaration et implementation de la fonction main.
// Fonction particulière car c'est le point d'entrée de votre programe.
func main() {
    // Appel de la fontion `Println` (Print Line) du package `fmt`
    // avec en argument la chaine de carractère "Hello ENSG!"
    fmt.Println("Hello ENSG!")
}
```

== Variables et Types (1/2)

Golang est un langage typé statiquement: Le type d'une variable une fois déclaré ne peut être changé.

(Bien que parfois frustrant, le compilateur est votre ami)

== Variables et Types (2/2)

Golang propose les types suivants

- Des types scalaires communs (string, int, float, bool) et moins communs (rune, byte)
- Des collections (maps, array  et slices)...
- Des type complexes (structures)
- Des pointeurs (*int, *string)
- Et des interfaces (error, interface{}, io.Reader...)

== Déclarer et Manipuler une Variable (1/3)

```golang
// Declare et initialise a sa valeur par defaut (zero value) une variable de type chaine de caractères.
var chaine string

// Assigne la valeur banane a la variable chaine.
chaine = "banane"

// Assigne la valeur 40 a la variable chaine.
chaine = 40 // Invalide: la valeur 40 n'est pas convertible (implicitement) en chaine de caractère

// Assigne la valeur 40 a la variabe 'entier'.
entier = 40 // Invalide: la variable entier n'est pas déclarée.
```

== Déclarer et Manipuler une Variable (2/3)

```golang
// Declare et initialise a la valeur 42 une variable appelée entier de type int.
var entier int = 42

// Assigne la valeur 12 a la variable entier.
entier = 12

// Declare et initialise a la valeur 43 une variable appelée autreEntier
// du type de la valeur à gauche (ici entier)
// C'est ce que l'on appelle de l'inference de type.
autreEntier := 43
// equivaut a l'expression suivante
// var autreEntier int = 43
```

== Déclarer et Manipuler une Variable (2/3)

```golang
// Déclare et initialise une variable entier1 de type entier a la valeur 42.
entier1 := 45

// Déclare et initialise une variable entier2 du type de la variabe entier1
// et **copie** la valeur de entier1 dans entier2.
entier2 := entier1

// Assigne la valeur 12 a la valeur entier2.
entier2 = 12

// Affiche sur la sortie standard la valeur des variables entier1 et entier2.
// Notez ici que la valeur entier1 n'est pas changée!
// On à bien fait une copie de la valeur.
fmt.Println(entier1, entier2) // Affiche: "45 12"
```

== Structures de contrôle

```golang
// Sans parenthèses, mais pas d'autres surprises :)
if a > 4 {

} else if c < 2 {

} else {

}
```

```golang
switch maVariable {
  case 4, 3:
    // executé si maVariabe est a 4 ou 3
  case 2, 1:
    // executé si maVariable est a 2 ou 1
  default:
    // executé si mavariable a une autre valuer.
}
```

== Structures (1/2)

- Une structure est un type composé de plusieurs attributs
- Ces attributs sont eux même typés
- La valeur par défaut (zero value) d'une structure est la valeur par defaut des types la composant

== Structures (2/2)

```golang
// Declare un type Dog de type structure, composée d'un attribut Name de type string
// et d'un attribut Age de type entier.
type Dog struct {
  Name  string
  Age   int
}
```

```golang
func main() {
  // ...
  // Declare et initialize a la valeur par défaut la variable dog1 de type Dog.
  var dog1 Dog // Name == "" (zero value string) et Age == 0 (zero value int)

  // Declare et initialize aux valeurs indiqués la variable dog2 de type Dog.
  dog2 := Dog{
    Name: "Michel",
    Age:  42,
  }

  fmt.Println(dog1, dog2)
  // ...
}
```

== Déclarer et Appeler une fonction (1/2)

- Une fonction en go est déclarée à l'aide du mot clé `func`
- Accepte des arguments et retourne une ou plusieurs valeurs
- Conventionellement, une fonction qui "peut échouer" retourne un resultat et une erreur

== Déclarer et Appeler une fonction (2/2)

```golang
// Declare une fonction `Greet`
func Greet(dog Dog) (string, error) {
  if dog.Name == "" {
    return string, errors.New("dog has no name :scream:")
  }

  // Concactene la chaine de catctère "Hello ",  avec le nom du chien
  return "Hello " + dog.Name, nil
}
```

```golang
func main() {
  doggy := Dog {
    Name: "michel",
    Age:  42
  }

  // Déclare et initialise les variables message et err avec les
  // valeurs de retour de la fonction Greet.
  message, err := Greet(doggy)

  if err != nil {
    // gère le cas d'erreur, explicitement :-)
    fmt.Println("Une erreur s'est produite", err)
    return
  }

  fmt.Println("Greeting message is", message)
}
```

== Que va afficher ce programme?

```golang
func changeName(dog Dog) {
  dog.Name = "roberto"
}

func main() {
  dog := Dog {
    Name: "jean-claude",
    Age:  50,
  }

  changeName(dog)

  fmt.Println("Hello", dog.Name)
}
```

== Passage par Valeur vs Passage par Pointeur (1/3)

- Passer une variable en argument d'une fonction déclénche une copie de cette variable.
- Cela signifie que la variable manipulé edans `changeName` est une variable différente (== se situe à une addresse différente en mémoire) de la variable manipulée dans la fonction main.
- Cette variable possède la même valeur que la variable issue de main, c'est une copie

== Passage par Valeur vs Passage par Pointeur(2/3)

- Solution: au lieu de passer la 'valeur' de la variable dog, nous allons passer son adresse en mémoire.
- C'est ce que l'on appelle un pointeur.

== Passage par Valeur vs Passage par Pointeur(3/3)

```golang
// changeNameFixed accepte un argument de type pointeur sur Dog
func changeNameFixed(dog *Dog) {
  dog.Name = "roberto"
}

func main() {
  dog := Dog {
    Name: "jean-claude",
    Age:  50,
  }

  // changeNameFixed est appellée en passant l'addresse de la variable dog
  // matérialisée par le '&' devant le nom de la variable
  changeNameFixed(&dog)

  fmt.Println("Hello", dog.Name)
}
```

== Pointeurs-Fu

- Un pointeur est une addresse memoire représentée sur 64bits
- La zero-value d'un pointeur est nil (0x000000)
- Quand on essaye d'accéder a la valeur d'un pointeur a la valeur `nil`... :boom:

== Exercice

- Ecrire un programme qui accepte un nom en argument.
- Si il n'y a pas d'argument, le programme indique qu'il faut passer un nom en argument et quite avec le status(1)
- Si il y à un argument, alors le programme affiche le ..
