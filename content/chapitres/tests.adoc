[{invert}]
= Tests Automatis√©s
== Qu'est ce qu'un test ?

C'est du code qui v√©rifie que du code fait ce qu'il est suppos√© faire.

== Pourquoi faire des tests ?

* Prouve que le logiciel se comporte comme attendu a tout moment.
* D√©tecte les impacts non anticip√©s des changements introduits
* Evite l'introduction de r√©gressions
* √âcrire des tests est un acte pr√©ventif et non curatif.

== Qu'est ce que l'on teste ?

* Une fonction
* Une combinaison de classes
* Un serveur applicatif et une base de donn√©es

On parle de **SUT**, System Under Test.

== Diff√©rents syst√®mes, Diff√©rentes Techniques de Tests

* Test unitaire
* Test d'integration
* Test de bout en bout
* Smoke tests

(La terminologie varie d'un d√©veloppeur / langage / entreprise / √©cosyst√®me √† l'autre)

== Test unitaire

* Test validant le bon comportement une unit√© de code.
* Prouve que l'unit√© de code interagit correctement avec les autres unit√©s.
* Un test d√©crit un cas
* Par exemple :
** Retourne les bonnes valeur en fonction des param√®tres donn√©s
** Appelle la bonne m√©thode du bon attribut avec les bons param√®tres

== Mise en place de l'exercice

* Depuis votre environnement de d√©veloppement, dans le repertoire du **fork** de votre bin√¥me
* Cr√©ez une feature branch `add-tests`.

== Ajout des Outils de Tests Automatis√©s au Projet (1/3)

L'execution de tests n√©cessite un outillage non ajout√© au projet

* Framework d'√©criture et d'execution de tests: `JUnit`
* Librairie de cr√©ation de mocks: `Mockito`
* Plugin maven de lancement de tests: `surefire`

== Ajout des Outils de Tests Automatis√© au Projet (2/3)

Ajoutez le bloc suivant au `pom.xml`

[source,xml]
----
<dependencies>
  <!-- ...  -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
  </dependency>
  <!-- ...  -->
</dependencies>
----

== Ajout des Outils de Tests Automatis√©s au Projet (3/3)

* Ex√©cutez les tests unitaires avec la commande `mvn test`
** Spoiler : `No tests to run...`

image::https://media.giphy.com/media/5x89XRx3sBZFC/giphy.gif[]

== Exercice : Corriger un Bug (1/11)

* La classe `ListMenuService` semble √™tre "bugg√©e"...
** Tous les noms des menus sont *TODO* üò±
* Quand on regarde l'impl√©mentation, on se rends compte que le probl√®me provient de la m√©thode statique `fromModel` de la classe `MenuDto`
* M√™me si la correction est ais√©e, on va d'abord √©crire un test unitaire qui valide le comportement du service.
* Notre SUT: `ListMenuService` + `MenuDto`

== Exercice : Corriger un Bug (2/11)

Mise en place du test

[source,java]
--
// src/test/java/com/cicdlectures/menuserver/service/ListMenuServiceTests.java

public class ListMenuServiceTests {

  private ListMenuService subject;

  @BeforeEach
  public void init() {
    subject = new ListMenuService(null);
  }

  @Test
  @DisplayName("lists all known menus")
  public void listsKnownMenus() {
     List<MenuDto> got = subject.listMenus();
  }
}
--

== Exercice : Corriger un Bug (3/11)

* Super on √† un test, il ne reste plus qu'√† le lancer avec `mvn test` üéâ
* Spoiler `java.lang.NullPointerException`

image::https://media.giphy.com/media/ceHKRKMR6Ojao/giphy.gif[]

== Exercice : Corriger un Bug (4/11)

* Le `ListMenuService` √† besoin d'un `MenuRepository` pour fonctionner.
* Cependant :
** On ne veut pas valider le comportement du `MenuRepository`, il est en dehors de notre SUT.
** Pire, on ne veut pas se connecter √† une base de donn√©e pendant un test unitaire.

== Exercice : Corriger un Bug (5/11)

Solution : On fournit une "fausse impl√©mentation" au service, un mock.

[source,java]
----
// src/test/java/com/cicdlectures/menuserver/service/ListMenuServiceTests.java

private MenuRepository menuRepository;

private UserService subject;

@BeforeEach
public void init() {
  this.repository = mock(MenuRepository.class);
  this.subject = new ListMenuService(this.repository);
}
----

== Exercice : Corriger un Bug (6/11)

Ce "mock" peut √™tre pilot√© dans les tests!

[source,java]
----
@Test
@DisplayName("lists all known menus")
public void listsKnownMenus() {
  // Quand le repository re√ßoit l'appel findAll
  // Alors il retourne la valeur null.
  when(repository.findAll()).thenReturn(null);
}
----

== Exercice : Corriger un Bug (7/11)

* Super on a un test unitaire, il ne reste plus qu'√† le lancer avec `mvn test` üéâ
* Spoiler: ‚úÖ

image::https://media.giphy.com/media/a0h7sAqON67nO/giphy.gif[]

== !

Sauf qu'on avait pas un bug √† corriger au fait?

== Exercice : Corriger un Bug (8/11)

Objectif: V√©rifier que les valeurs retourn√©es par le `ListMenuService` sont coh√©rentes
avec les donn√©es en base, pour cela il nous faut:

* Pr√©parer un jeu de donn√©es de test et configurer le mock du repository pour qu'il le retourne
* Appeler notre service
* Comparer le r√©sultat obtenu du service avec des valeurs attendues.

== Exercice : Corriger un Bug (9/11)

[source,java]
----
@Test
@DisplayName("lists all known menus")
public void listsKnownMenus() {
  // D√©fini une liste de menus avec un menus.
  Iterable<Menu> existingMenus = Arrays.asList(
    new Menu(
      Long.valueOf(1),
      "Christmas menu",
      new HashSet<>(
        Arrays.asList(
          new Dish(Long.valueOf(1), "Turkey", null),
          new Dish(Long.valueOf(2), "Pecan Pie", null)
        )
      )
    ),
  )

  // On configure le menuRepository pour qu'il retourne notre liste de menus.
  when(menuRepository.findAll()).thenReturn(existingMenus);

  // On appelle notre sujet
  List<MenuDto> gotMenus = subject.listMenus();

  // On d√©fini wantMenus, les r√©sultats attendus
  Iterable<MenuDto> wantMenus = Arrays.asList(
      new MenuDto(
        Long.valueOf(1),
        "Christmas menu",
        new HashSet<>(
          Arrays.asList(
            new DishDto(Long.valueOf(1), "Turkey"),
            new DishDto(Long.valueOf(2), "Pecan Pie")
          )
        )
      )
    );

    // On compare la valeur obtenue avec la valeur attendue.
    assertEquals(wantMenus, gotMenus);
}
----

== Exercice : Corriger un Bug (10/11)

* Super on a un test unitaire (qui teste!), il ne reste plus qu'√† le lancer avec `mvn test` üéâ
* Spoiler:

[source,bash]
----
[ERROR] Failures:
[ERROR]   ListMenuServiceTests.listsKnownMenus:66
expected:
  <[MenuDto(id=1, name=Christmas menu, dishes=[DishDto(id=2, name=Pecan Pie), DishDto(id=1, name=Turkey)])]>
but was:
  <[MenuDto(id=1, name=TODO LOL, dishes=[DishDto(id=2, name=Pecan Pie), DishDto(id=1, name=Turkey)])]>
----

image::https://media.giphy.com/media/FG14fnY17opr2/giphy.gif[]

== Exercice : Corriger un Bug (11/11)

* Il ne reste plus qu'a faire la correction et le tour est jou√©!

image::https://media.giphy.com/media/111ebonMs90YLu/giphy.gif[width="800"]

== Test Unitaire : Quelques R√®gles

* Un test unitaire teste un et un seul comportement
* Faites attention a ce que votre test teste vraiment quelque chose!
** Avec les mocks, c'est facile de se faire pi√©ger.
* Essayez, dans la mesure du possible, d'√©crire vos tests (qui √©chouent) avant d'√©crire votre code.
* Il n'y a pas de d√©finition ferme du SUT
** Attention √† garder une taille raisonnable (quelques classes).
* Privil√©giez les tests de m√©thodes publiques.

== Test Unitaire : Pro / Cons

* ‚úÖ Super rapides (<1s) et l√©gers a executer
* ‚úÖ Pousse √† avoir un bon design de code
* ‚úÖ Efficaces pour tester des cas limites
* ‚ùå Peu r√©alistes

[%notitle]
== fail

video::ut-fail-1.mp4[width="600",options="autoplay,loop,nocontrols"]

[%notitle]
== fail2

video::ut-fail-2.mp4[width="600",options="autoplay,loop,nocontrols"]

[{invert}]
== !

Tester des composants ind√©pendamment ne prouve pas que le syst√®me fonctionne une fois int√©gr√©!

== Solution: Tests d'int√©gration

* Test validant qu‚Äôun assemblage d‚Äôunit√©s se comportent comme pr√©vu.
* Teste votre application au travers de toute ses couches
* Par exemple avec menu server:
**  Prouve que GET /menus retourne la liste des menus enregistr√©s en base
**  Prouve que POST /menus enregistre un nouveau menu en base avec ses plats.

== D√©finition du SUT (1/2)

image::architecture.png[]

== D√©finition du SUT (2/2)

Un test d'int√©gration doit a chaque test:

* D√©maRrer et provisionner un environnement d‚Äôex√©cution (une DB, Elasticsearch, un autre service...)
* D√©marrer votre application
* Jouer un sc√©nario de test
* √âteindre et nettoyer son environnement d‚Äôex√©cution pour garantir l'isolation des tests

== !

Ce sont des tests plus lents et plus complexes que des tests unitaires.

== Configuration de Maven (1/2)

[source,xml]
----
<plugins>
  <plugin>
    <!-- Configure le maven-surefire-plugin -->
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <configuration>
      <!-- Desactive tous les tests pour l'execution par defaut -->
      <skipTests>true</skipTests>
    </configuration>
    <executions>
      <execution>
        <!--Cr√©e une premi√®re execution pour jouer les tests unitaires -->
        <id>unit</id>
        <phase>test</phase>
        <goals>
          <goal>test</goal>
        </goals>
        <configuration>
          <skipTests>${skipUnitTests}</skipTests>
          <!-- Inclue et execute les tests contenus dans les fichiers ayant le suffixe Tests.java-->
          <includes>
            <include>**/*Tests.java</include>
          </includes>
        </configuration>
      </execution>
      <execution>
        <!--Cr√©e une seconde execution pour jouer les tests d'integration -->
        <id>integration</id>
        <phase>integration-test</phase>
        <goals>
          <goal>test</goal>
        </goals>
        <configuration>
          <skipTests>false</skipTests>
          <includes>
            <!-- Inclue et execute les tests contenus dans les fichiers ayant le suffixe IT.java-->
            <include>**/*IT.java</include>
          </includes>
        </configuration>
      </execution>
    </executions>
  </plugin>
</plugins>
----

== Configuration de Maven (2/2)

Cela cr√©e les commandes suivantes:

- `mvn test`: lance les tests unitaires
- `mvn verify`: lance les tests unitaires et d'integration
- `mvn verify -DskipUnitTests=true`: lance uniquement les tests d'integration

== Mise en Place d'un Test d'Int√©gration

[source,java]
----
// src/test/java/com/cicdlectures/menuserver/controller/MenuControllerIT.java
// Lance l'application sur un port al√©atoire.
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
// Indique de relancer l'application √† chaque test.
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class MenuControllerIT {

  @LocalServerPort
  private int port;

  private URL getMenusURL() throws Exception {
    return new URL("http://localhost:" + port + "/menus");
  }

  @Test
  @DisplayName("lists all known menus")
  public void listsAllMenus() throws Exception {
  }
}
----

== Outillage fourni par SpringBoot

[source, java]
----
// Injecte automatiquement l'instance du menu repository
@Autowired
private MenuRepository menuRepository;

// Injecte automatiquement l'instance du TestRestTemplate
@Autowired
private TestRestTemplate template;

public void listExitingMenus() throws Exception {
   // Effectue une requ√™te GET /menus
   ResponseEntity<MenuDto[]> response = this.template.getForEntity(getMenusURL().toString(), MenuDto[].class);

   //Parse le payload de la r√©ponse sous forme d'array de MenuDto
   MenuDto[] gotMenus = response.getBody();
}
----

== Exercice: Impl√©mentez le test d'int√©gration

* Provisionne la base de donn√©e avec des donn√©es fixes
* Effectue une requ√™te HTTP sur `GET /menus`
* Parse la r√©ponse sous forme de `MenuDto`
* V√©rifie que le status de la r√©ponse est 200.
* Compare la r√©ponse √† un r√©sultat attendu de la m√™me fa√ßon que dans le test unitaire.

== Exercice: Activez les tests dans votre CI

Changez le workflow de ci de votre bin√¥me (ou le votre) pour qu'√† chaque build:

* Les tests unitaires soient lanc√©s
* Les tests d'integration soient lanc√©s
