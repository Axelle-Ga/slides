[{invert}]
= Travailler en √©quipe ?

== Limites de bosser seul

* Capacit√© finie de travail
* Victime de propres biais
* On ne sait pas tout, tout le temps ?

== !

image:solo.gif[width="500"]

== Travailler en √©quipe ? Une si bonne id√©e ?

* ... Mais il faut communiquer ?
* ... Mais tout le monde n'a pas les m√™mes comp√©tences ?
* ... Mais tout le monde y code pas pareil ?

== !

Collaborer c'est pas √©vident, mais il existe des outils et des methodes pour vous aider.

[.small]
Cela reste des outils, √ßa ne r√©soud pas tout non plus.

== Git multijoueur

* Git permet de collaborer assez ais√©ment
* Chaque d√©veloppeur cr√©e et publie des commits...
* ... et rapatrie ceux de de ses camarades !
* C'est un outil tr√®s flexible... chacun peut faire ce qu'il lui semble bon !

== ... et (souvent) √ßa finit comme √ßa !

image:bloing.jpeg[]

== Quelques r√®gles pour √©viter √ßa !

[{invert}]
== Disclaimer

Attachez vous aux id√©es g√©n√©rales... les d√©tails varient d'un projet √† l'autre!

== Gestion des branches

* Les "versions" du logiciel sont maintenues sur des branches principales
(main, staging)
* Ces branches refl√™tent l'√©tat du logiciel
** **main**: version actuelle en production
** **staging**: prochaine version

== !

image:gitmulti1.svg[]

== Gestion des branches

* Chaque groupe de travail (d√©veloppeur, bin√¥me...)
** Cr√©e une branche de travail √† partir de la branche staging
** Une branche de travail correspond √† *une chose √† la fois*
** Pousse des commits dessus qui impl√©mentent le changement

== !

image:gitmulti2.svg[]

== !

image:gitmulti3.svg[]

Quand le travail est fini, la branche de travail est merg√©e dans staging

== !

image:gitmulti4.svg[]

== Gestion des remotes

La grande question: o√π vivent ces branches ?

== Plusieurs mod√®les possibles

* Un remote pour les gouverner tous !
* Chacun son propre remote (et les commits seront bien gard√©s)
* ... whatever floats your boat!

== Un remote pour les gouverner tous

Tous les d√©veloppeurs envoient leur commits et branches sur le m√™me remote

* Simple a g√©rer ...
* ... mais n√©cessite que tous les contributeurs aient acc√®s au d√©pot
** Adapt√© a l'entreprise, peu adapt√© au monde de l'open source

== !

image:remotemulti1.svg[]

== Chacun son propre remote

* La motivation est le contr√¥le d'acc√®s
** Tout le monde peut lire le d√©pot principal. Personne ne peut √©crire desuss.
** Tout le monde peut dupliquer le d√©pot public et √©crire sur sa copie.
** Toute modification du d√©pot principal passe par une proc√©dure de revue.
** Si la revue est valid√©e, alors la branche est "merg√©e" dans la branche cible
* C'est le mod√®le pouss√© par GitHub !

== !

image:remotemulti2.svg[]

== Forks ! Forks everywhere !

Dans la terminologie GitHub:

* Un fork est un remote copi√© d'un d√©pot principal
** C'est la o√π les contributeurs poussent leur branche de travail.
* Les branches de version (main, staging...) vivent sur le d√©pot principal
* La proc√©dure de ramener un changement d'un fork vers un d√©pot principal s'appelle une **Pull Request (PR)**.

== Exercice: Cr√©ez un fork

* Nous allons vous  faire forker les d√©pots cr√©√©s dans le chapitre GitHub.
* Trouvez vous un bin√¥me dans le groupe.
* Rendez vous link:https://docs.google.com/spreadsheets/d/1iWwCiS-jApvfSMETMG22N-wDhxVNvIrR4IoM-v2YYas/edit?usp=sharing[sur cette page,window="_blank"] pour enregistrer votre bin√¥me, et indiquez les liens de vos d√©p√¥ts respectifs.
* Depuis la page du d√©pot de votre bin√¥me, cliquez en haut √† droite sur le bouton **Fork**.

== La proc√©dure de Pull Request

*Objectif* : Valider les changements d'un contributeur

* Technique : est-ce que √ßa marche ? est-ce maintenable ?
* Fonctionnel : est-ce que le code fait ce que l'on veux ?
* Humain : Propager la connaissance par la revue de code.
* M√©thode : Tracer les changements.

== Anatomie d'une Pull Request sur GitHub

* **Branche source**: La branche portant le changement
* **Branche cible**: La branche dans lequel le changement va √™tre merg√©.
* **Titre**: d√©crit de fa√ßon concise le changement apport√©
* **Description**: d√©crit de fa√ßon d√©taill√©e le changement. Doit donner toutes les "cl√©s de lecture" de la PR √† un relecteur
* **Labels**: meta informations permettant de suivre le type de la PR (bugfix, feature?)
* **Historique de commit**: Lors d'une pull request, une attention particuli√®re doit √™tre port√©e aux commits (bien nomm√©s, atomiques), c'est un outil aidant √† la relecture!

== Exercice: faites votre changement sur votre fork

Acc√©dez √† link:https://gitpod.io#https://github.com/cicd-lectures/demoapp[l'environnement GitPod,window="_blank"], puis depuis le terminal jouez les commandes suivantes:

[source,bash]
--
cd /workspace/

# Clonez votre fork
git clone <url_de_votre_fork>

# Cr√©ez votre feature branch
git checkout -b <nom-de-votre-feature-branch>

# Changez le readme ou ajoutez un nouveau fichier.
# (bonus si c'est rigolo :p)
# Et comittez le ;)

# Publiez votre changement sur votre remote "fork√©"
git push origin <nom-de-votre-feature-branch>
--

== Exercice: Ouvrez votre PR

* Rendez vous sur la page de votre projet
* S√©lectionnez votre branche dans le menu d√©roulant "branches"  en haut a gauche.
* Cliquez ensuite sur le bouton ouvrir une pull request
* Remplissez le contenu de votre PR (titre, description, labels) et validez.

== Validations d'une PR

* Revue de code
* Validation automatis√©e

== Revue de code ?

* Validation par un ou plusieurs pair (techniques et non technique) des changements que l'on veut ramener
* Relecture des changements depuis github (ou depuis l'environement de poste du developpeur)
* Chaque relecteur emet des commentaires ou des suggestions de changement.
* Quand un relecteur est satisfait d'un le changement, il l'approuve.

== !

* La revue de code est un **exercice difficile** et **potentiellement frustrant** pour les deux parties.
** Comme sur Twitter, on est bien √† l'abri derrir√®re son √©cran ;=)
* En tant que contributeur, **soyez respectueux** de vos relecteurs : votre changement peut √™tre refus√© et c'est quelque chose de normal.
* En tant que relecteur, **soyez respectueux** du travail effectu√©, m√™me si celui ci comporte des erreurs ou ne correspond pas √† vos attentes.

üí° Astuce: link:https://github.com/franckverrot/clamav-client/pull/12#discussion_r526222319[Proposez des solutions] plut√¥t que simplement pointer les probl√®mes.

== Validation automatis√©e

**Objectif**: Valider que le changement n'introduit pas de r√©gressions dans le projet

* A chaque fois qu'un nouveau commit est cr√©√© dans une PR, une succession de validations ("checks") sont d√©clench√©s par GitHub
* Effectue des v√©rifications automatis√©es sur un commit de merge entre votre branche cible et la branche de PR

== Quelques exemples

* Analyse syntaxique du code (lint), pour d√©tecter les erreurs potentielles ou les violations du guide de style
* Compilation du projet
* Execution des tests automatis√©s du projet (unit, integration)
* D√©ploiement du projet dans un environnement de test (coucou Netlify !)

Ces "checks" peuvent √™tres execut√©s par votre moteur de CI ou des outils externes.

== !

*R√®gle d'or*: Si le CI est rouge, on ne merge pas la pull request !

[.small]
M√™me si le linter il√©con, m√™me si on a la flemme et s√©panou qui avons cass√© le CI.

== Exercice Pull Request: Relisez votre PR re√ßue

* Vous devriez avoir re√ßu une PR de votre bin√¥me :-)
* Relisez le changement de la PR
* Effectuez quelques commentaires (bonus: utilisez la suggestion de changements)
* Si elle vous convient, mergez la pull request dans votre d√©p√¥t.
